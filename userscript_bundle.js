// Userscript Bundle - Auto-generated by bundler.js
// Generated on: 2026-01-13T02:43:45.020Z

const script_func_0 = () => {
    // Wait for DOM to be ready before executing
    const executeScript = () => {
// ==UserScript==
// @name        Auto Focus 1337x Search
// @author      Matthew Daniel Murphy
// @description Auto focus the search input on 1337x.to
// @version     1.0
// @match       *://1337x.to
// @grant       none
// ==/UserScript==

;(() => {
	"use strict"

	const focusSearch = () => {
		const input = document.querySelector("#search-index-form input")
		if (input) {
			input.focus()
			return true
		}
		return false
	}

	if (!focusSearch()) {
		const observer = new MutationObserver((mutations, obs) => {
			if (focusSearch()) {
				obs.disconnect()
			}
		})
		observer.observe(document.body, { childList: true, subtree: true })

		// Fallback timeout to stop observing after a while
		setTimeout(() => observer.disconnect(), 5000)
	}
})()

    };
    
    // Check if DOM is already ready
    if (document.readyState === 'loading') {
        // DOM is still loading, wait for DOMContentLoaded
        document.addEventListener('DOMContentLoaded', executeScript);
    } else {
        // DOM is already ready, execute immediately
        executeScript();
    }
};

// Expose function to global scope for dispatcher access
window.script_func_0 = script_func_0;

const script_func_1 = () => {
    // Wait for DOM to be ready before executing
    const executeScript = () => {
// ==UserScript==
// @name         Perplexity.ai Improvements
// @version      0.1
// @description  Various improvements to Perplexity.ai
// @author       You
// @icon         https://www.google.com/s2/favicons?sz=64&domain=perplexity.ai
// @namespace    http://tampermonkey.net/
// @match        https://www.perplexity.ai/*
// @grant        none
// ==/UserScript==

// IMPROVEMENTS
//     1. Text Selection Follow-Up Tooltip to follow-up with selected text, optionally with a question
//     2. Code Box Copy button at the bottom of code
//     3. Change Thread Dropdown Menu Buttons to Delete Buttons
//     4. Remove sidebar and set main content to full-width
//     5. Remove Perplexity for Mac Ad

//!		 1. Text Selection Follow-Up Tooltip
;(() => {
	// Create tooltip element
	const tooltip = document.createElement("div")
	tooltip.id = "selection-tooltip"
	tooltip.style.cssText = `
      position: absolute;
      background: var(--tooltip-bg);
      color: var(--text-main);
      padding: 8px;
      border-radius: 8px;
      font-size: 14px;
      display: none;
      z-index: 9999;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      border: 1px solid var(--border-main);
    `
	document.body.appendChild(tooltip)

	// Create button function
	const createButton = (text, onClick) => {
		const button = document.createElement("button")
		button.textContent = text
		button.className = "font-sans"
		button.style.cssText = `
        background: var(--bg-main);
        border: 1px solid var(--border-main);
        color: var(--text-main);
        padding: 6px 10px;
        margin: 2px;
        cursor: pointer;
        border-radius: 6px;
        font-size: 14px;
        transition: background 0.3s;
      `
		button.onmouseover = () => (button.style.background = "var(--bg-hover)")
		button.onmouseout = () => (button.style.background = "var(--bg-main)")
		button.onclick = onClick
		return button
	}

	// Handle action function
	const handleAction = (withQuestion = false) => {
		const selectedText = window.getSelection().toString()
		const textarea = document.querySelector('textarea[placeholder="Ask follow-up"]')
		if (textarea) {
			textarea.focus()
			const textToInsert = `You said: "${selectedText}"${withQuestion ? "; " : ""}`
			document.execCommand("insertText", false, textToInsert)
			textarea.dispatchEvent(new Event("input", { bubbles: true }))
			if (!withQuestion) {
				setTimeout(() => {
					const submitButton = document.querySelector('button[aria-label="Submit"]')
					if (submitButton && !submitButton.disabled) {
						submitButton.click()
					}
				}, 100)
			}
		}
		tooltip.style.display = "none"
	}

	// Add buttons to tooltip
	tooltip.appendChild(createButton("Follow-up", () => handleAction(false)))
	tooltip.appendChild(createButton("With question", () => handleAction(true)))

	// Handle selection function
	function handleSelection() {
		const selection = window.getSelection()
		const answerDivs = document.querySelectorAll(".prose")
		if (selection.toString() && Array.from(answerDivs).some((div) => div.contains(selection.anchorNode) || div.contains(selection.focusNode))) {
			const range = selection.getRangeAt(0).getBoundingClientRect()
			const scrollX = window.scrollX || window.pageXOffset
			const scrollY = window.scrollY || window.pageYOffset
			tooltip.style.left = `${range.left + scrollX}px`
			tooltip.style.top = `${range.bottom + scrollY}px`
			tooltip.style.display = "block"
		} else {
			tooltip.style.display = "none"
		}
	}

	// Add event listener
	document.addEventListener("mouseup", handleSelection)

	// Add styles
	const style = document.createElement("style")
	style.textContent = `
      :root {
        --tooltip-bg: #FCFCF9;
      }
      @media (prefers-color-scheme: dark) {
        :root {
          --tooltip-bg: #202222;
        }
      }
    `
	document.head.appendChild(style)
})()

//!		 2. Code Box Copy button at the bottom of code
;(() => {
	const style = document.createElement("style")
	style.textContent = `
        .codeWrapper > div:nth-of-type(2) button {
            top: unset !important;
            bottom: .5em !important;
        }
    `
	document.head.appendChild(style)

	console.log("Style added successfully")
})()

//!		 3. Change Thread Dropdown Menu Buttons to Delete Buttons
;(function () {
	let dropdownClicked = false
	let deleteButtonClicked = false
	let confirmButtonClicked = false
	const processedDropdowns = new Set() // Track dropdowns that already have listeners attached

	// Clear previous intervals and observers
	function clearAllIntervals() {
		if (window._deleteButtonInterval) {
			clearInterval(window._deleteButtonInterval)
			window._deleteButtonInterval = null
		}
		if (window._confirmDialogInterval) {
			clearInterval(window._confirmDialogInterval)
			window._confirmDialogInterval = null
		}
		if (window._dropdownOpacityInterval) {
			clearInterval(window._dropdownOpacityInterval)
			window._dropdownOpacityInterval = null
		}
		if (window._confirmDialogOpacityInterval) {
			clearInterval(window._confirmDialogOpacityInterval)
			window._confirmDialogOpacityInterval = null
		}
	}

	// Function to stop all functionality
	function stopScript() {
		clearAllIntervals() // Stop all ongoing intervals
		mutationObserver.disconnect() // Disconnect the mutation observer
		console.log("Script stopped: URL is no longer /library")
	}

	// Function to start the script
	function startScript() {
		console.log("Script started: /library detected.")
		// Replace ellipsis with delete icon
		replaceEllipsisWithDeleteIcon()
		// Attach event listeners to dropdown buttons
		attachEventListeners()
		// Start monitoring URL changes for navigating away
		monitorUrlChange()
		// Start observing DOM for new dropdown menus being added
		mutationObserver.observe(document.body, { childList: true, subtree: true })
	}

	// Detect URL changes and stop the script if not on the /library page
	function monitorUrlChange() {
		let currentUrl = window.location.pathname
		setInterval(() => {
			if (window.location.pathname !== currentUrl) {
				currentUrl = window.location.pathname
				if (!currentUrl.includes("/library")) {
					stopScript() // Stop the script if the URL is no longer /library
				} else {
					startScript() // Restart the script when back to /library
				}
			}
		}, 500) // Check every 500ms for URL changes
	}

	// Replace ellipsis with the delete icon
	function replaceEllipsisWithDeleteIcon() {
		const dropdowns = document.querySelectorAll('button[data-testid="thread-dropdown-menu"]')
		dropdowns.forEach((dropdown) => {
			if (!processedDropdowns.has(dropdown)) {
				const ellipsisIcon = dropdown.querySelector('div > svg[data-icon="ellipsis"]')
				if (ellipsisIcon) {
					const deleteIcon = document.createElementNS("http://www.w3.org/2000/svg", "svg")
					deleteIcon.setAttribute("aria-hidden", "true")
					deleteIcon.setAttribute("focusable", "false")
					deleteIcon.setAttribute("data-prefix", "far")
					deleteIcon.setAttribute("data-icon", "trash")
					deleteIcon.setAttribute("class", "svg-inline--fa fa-trash fa-fw")
					deleteIcon.setAttribute("role", "img")
					deleteIcon.setAttribute("viewBox", "0 0 448 512")

					const path = document.createElementNS("http://www.w3.org/2000/svg", "path")
					path.setAttribute("fill", "currentColor")
					path.setAttribute(
						"d",
						"M177.1 48h93.7c2.7 0 5.2 1.3 6.7 3.6l19 28.4h-145l19-28.4c1.5-2.2 4-3.6 6.7-3.6zM354.2 80L317.5 24.9C307.1 9.4 289.6 0 270.9 0H177.1c-18.7 0-36.2 9.4-46.6 24.9L93.8 80H80.1 32 24C10.7 80 0 90.7 0 104s10.7 24 24 24H35.6L59.6 452.7c2.5 33.4 30.3 59.3 63.8 59.3H324.6c33.5 0 61.3-25.9 63.8-59.3L412.4 128H424c13.3 0 24-10.7 24-24s-10.7-24-24-24h-8H367.9 354.2zm10.1 48L340.5 449.2c-.6 8.4-7.6 14.8-16 14.8H123.4c-8.4 0-15.3-6.5-16-14.8L83.7 128H364.3z"
					)

					deleteIcon.appendChild(path)
					ellipsisIcon.parentNode.replaceChild(deleteIcon, ellipsisIcon)
					processedDropdowns.add(dropdown) // Mark as processed
				}
			}
		})
	}

	// Add event listeners to dropdown buttons
	function attachEventListeners() {
		document.querySelectorAll('button[data-testid="thread-dropdown-menu"]:not([data-listener="added"])').forEach((dropdownMenu) => {
			dropdownMenu.addEventListener("click", () => {
				if (dropdownClicked) return // Prevent multiple clicks on the same dropdown
				dropdownClicked = true
				clearAllIntervals() // Clear any previous intervals before starting the process

				console.log("Dropdown menu clicked.")

				// Start looking for the delete button
				setTimeout(checkDeleteButton, 50) // Reduced initial delay to 50ms

				// Mark the dropdown as having had a listener added
				dropdownMenu.setAttribute("data-listener", "added")

				// Start hiding dropdown and confirm dialog elements
				startHidingElements()
			})
		})
	}

	// Observe DOM mutations for adding new dropdowns dynamically
	const mutationObserver = new MutationObserver(() => {
		// Only handle mutations that are adding new dropdown menus
		if (dropdownClicked) return // Ignore mutations that happen during ongoing thread deletion

		console.log("Mutation detected: Checking for new dropdowns...")
		replaceEllipsisWithDeleteIcon() // Check for new dropdowns added to the page
		attachEventListeners() // Add listeners to new dropdowns
	})

	// Function to check for the delete button
	function checkDeleteButton() {
		if (deleteButtonClicked) return // Prevent multiple clicks on the delete button

		window._deleteButtonInterval = setInterval(() => {
			const deleteButton = document.querySelector('div[data-testid="thread-delete"]')
			if (deleteButton) {
				const child = deleteButton.querySelector("*")
				if (child) {
					child.click()
					deleteButtonClicked = true
					console.log("Delete button clicked.")
					clearInterval(window._deleteButtonInterval) // Stop checking for the delete button

					// Wait 50ms before checking for the confirmation dialog
					setTimeout(checkConfirmationDialog, 50) // Reduced delay to 50ms
				}
			}
		}, 50) // Reduced interval to 50ms for checking delete button
	}

	// Function to check for the confirmation dialog
	function checkConfirmationDialog() {
		if (confirmButtonClicked) return // Prevent multiple clicks on the confirm button

		window._confirmDialogInterval = setInterval(() => {
			const confirmButton = Array.from(document.querySelectorAll("div")).find((div) => div.textContent.trim() === "Confirm")

			if (confirmButton) {
				confirmButton.click()
				confirmButtonClicked = true
				console.log("Confirm button clicked.")
				clearInterval(window._confirmDialogInterval) // Stop checking for the confirm dialog

				// Reset the flags for the next dropdown click
				resetFlags()
			}
		}, 150) // Reduced interval to 150ms for checking the confirm button
	}

	// Reset flags after completing a thread deletion process
	function resetFlags() {
		dropdownClicked = false
		deleteButtonClicked = false
		confirmButtonClicked = false
	}

	// Start the process of hiding elements after dropdown click
	function startHidingElements() {
		window._dropdownOpacityInterval = setInterval(() => {
			const deleteButton = document.querySelector('div[data-testid="thread-delete"]')
			if (deleteButton) {
				const dropdownMenuParent = deleteButton.parentElement.parentElement.parentElement
				if (dropdownMenuParent && dropdownMenuParent.style.opacity !== "0") {
					dropdownMenuParent.style.opacity = "0"
					console.log("Dropdown menu hidden.")
				}
			}

			const confirmButton = Array.from(document.querySelectorAll("div")).find((div) => div.textContent.trim() === "Confirm")
			if (confirmButton) {
				const confirmDialogParent = confirmButton.closest("div")
				if (confirmDialogParent && confirmDialogParent.style.opacity !== "0") {
					confirmDialogParent.style.opacity = "0"
					console.log("Confirm dialog hidden.")
				}
			}
		}, 1) // Use 1ms interval to hide elements immediately
	}

	// Initially check if we're on /library
	if (window.location.pathname.includes("/library")) {
		startScript() // Start the script if we're on the /library page
	} else {
		monitorUrlChange() // Otherwise, monitor URL changes
	}

	//!     4. Remove Annoyances

	// Function to modify and remove elements
	function removeAnnoyances() {
		console.log("DOM updated; Removing annoyances...")
		// removeSidebar() //? sidebar should be removed by separate script that does google searches
		removePerplexityMacPromo()
		removeFreePlanNotice()
	}

	// Create a MutationObserver to watch for DOM mutations
	const observer = new MutationObserver(removeAnnoyances)

	// Start observing the document for child changes (additions/removals)
	observer.observe(document.body, {
		childList: true,
		subtree: true,
	})

	// Run the function once initially to cover any existing elements
	removeAnnoyances()

	function removeSidebar() {
		// Change class of div.col-span-8 to col-span-12
		document.querySelectorAll("div.col-span-8").forEach((el) => {
			el.classList.remove("col-span-8")
			el.classList.add("col-span-12")
			el.style.maxWidth = "42rem"
		})

		// Remove any div.col-span-4.isolate elements
		document.querySelectorAll("div.col-span-4.isolate").forEach((el) => {
			el.remove()
		})
	}

	function removePerplexityMacPromo() {
		const element = document.querySelector("img[alt*='Perplexity for Mac']")
		if (element && element.parentElement) {
			element.parentElement.remove()
		}
	}

	function removeFreePlanNotice() {
		const upgradeButton = Array.from(document.querySelectorAll("button")).find((button) => button.innerText.includes("Upgrade"))
		if (upgradeButton?.parentElement) {
			upgradeButton.parentElement.remove()
		}
	}
	// find div.grid with 4 divs inside it
	const grid = document.querySelector("div.grid")
	if (grid && grid.children.length === 4) {
		grid.remove()
	}
})()

    };
    
    // Check if DOM is already ready
    if (document.readyState === 'loading') {
        // DOM is still loading, wait for DOMContentLoaded
        document.addEventListener('DOMContentLoaded', executeScript);
    } else {
        // DOM is already ready, execute immediately
        executeScript();
    }
};

// Expose function to global scope for dispatcher access
window.script_func_1 = script_func_1;

const script_func_2 = () => {
    // Wait for DOM to be ready before executing
    const executeScript = () => {
// ==UserScript==
// @name        Amazon Filter
// @description Filter products on amazon.ca searches
// @match       https://www.amazon.ca/s*
// @version     1.0
// @grant       none
// ==/UserScript==

let observer

function addFilterInput() {
	const targetDiv = document.getElementById("s-skipLinkTargetForMainSearchResults")
	if (!targetDiv) {
		// If target div isn't found, retry after a short delay
		setTimeout(addFilterInput, 500)
		return
	}

	if (document.getElementById("amazon-filter-input")) return

	const filterContainer = document.createElement("div")
	filterContainer.style.display = "flex"
	filterContainer.style.alignItems = "center"
	filterContainer.style.margin = "10px 0"

	const filterInput = document.createElement("input")
	filterInput.type = "text"
	filterInput.id = "amazon-filter-input"
	filterInput.placeholder = "Enter filter terms (comma-separated)"
	filterInput.style.width = "300px"
	filterInput.style.padding = "5px"
	filterInput.style.marginRight = "10px"

	const filterCount = document.createElement("span")
	filterCount.id = "amazon-filter-count"

	filterContainer.appendChild(filterInput)
	filterContainer.appendChild(filterCount)
	targetDiv.parentNode.insertBefore(filterContainer, targetDiv)

	filterInput.addEventListener("input", () => {
		filterAmazonResults(filterInput.value)
	})

	// Set up the observer for dynamically added content
	setupObserver()
}

function filterAmazonResults(filterString) {
	const filterTerms = filterString
		.split(",")
		.map((term) => term.trim().toLowerCase())
		.filter((term) => term !== "")

	// Update selector to match current Amazon structure
	const productCards = document.querySelectorAll("div[data-asin]")
	console.log("Found products:", productCards.length) // Debug logging
	
	let filteredCount = 0
	const productTitles = []
	productCards.forEach((card) => {
		// Update selector to match current title structure
		const titleElement = card.querySelector("h2 span")
		if (titleElement) {
			const title = titleElement.textContent.toLowerCase()
			productTitles.push(title)
			const shouldFilter = filterTerms.some((term) => title.includes(term))
			if (shouldFilter) {
				card.style.display = "none"
				filteredCount++
			} else {
				card.style.display = "block"
			}
		}
	})

	window.logProducts = () => {
		console.log(productTitles)
	}

	updateFilterCount(filteredCount)
}

function updateFilterCount(count) {
	const filterCount = document.getElementById("amazon-filter-count")
	if (filterCount) {
		filterCount.textContent = count > 0 ? `${count} result${count !== 1 ? "s" : ""} filtered out` : ""
	}
}

function setupObserver() {
	// Update selector to match current structure
	const targetNode = document.querySelector("div.s-main-slot")
	if (!targetNode) {
		// If target node isn't found, retry after a short delay
		setTimeout(setupObserver, 500)
		return
	}

	const config = { childList: true, subtree: true }

	const callback = function (mutationsList, observer) {
		for (let mutation of mutationsList) {
			if (mutation.type === "childList") {
				const filterInput = document.getElementById("amazon-filter-input")
				if (filterInput && filterInput.value) {
					filterAmazonResults(filterInput.value)
				}
			}
		}
	}

	if (observer) {
		observer.disconnect()
	}
	observer = new MutationObserver(callback)
	observer.observe(targetNode, config)
}

// Run the script immediately instead of waiting for DOMContentLoaded
addFilterInput()

    };
    
    // Check if DOM is already ready
    if (document.readyState === 'loading') {
        // DOM is still loading, wait for DOMContentLoaded
        document.addEventListener('DOMContentLoaded', executeScript);
    } else {
        // DOM is already ready, execute immediately
        executeScript();
    }
};

// Expose function to global scope for dispatcher access
window.script_func_2 = script_func_2;

const script_func_3 = () => {
    // Wait for DOM to be ready before executing
    const executeScript = () => {
// ==UserScript==
// @name        Open Apple Music links in Music App
// @author      Matthew Daniel Murphy
// @description Changes Apple Music web links (https://) to app links (music://) to open in the native Music app.
// @version     1.0
// @match       *://*/*
// @grant       none
// ==/UserScript==

(() => {
    'use strict';

    const processLinks = (container) => {
        // Find all unprocessed links pointing to Apple Music
        const links = container.querySelectorAll('a[href*="music.apple.com"]:not([data-am-link-processed])');
        
        links.forEach(link => {
            // Mark the link as processed to avoid an infinite loop
            link.setAttribute('data-am-link-processed', 'true');
            
            // Replace https protocol with the music app protocol
            if (link.href.startsWith('https://music.apple.com/') || link.href.startsWith('https://geo.music.apple.com/')) {
                link.href = link.href.replace('https://', 'music://');
                console.log(`Updated Apple Music link: ${link.href}`);
            }
        });
    };

    // Initial run on page load
    processLinks(document.body);

    // Use a MutationObserver to handle links added dynamically (e.g., in SPAs)
    const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
            if (mutation.addedNodes.length) {
                processLinks(document.body);
            }
        });
    });

    // Start observing the entire document body for changes
    observer.observe(document.body, { childList: true, subtree: true });
})();

  
    };
    
    // Check if DOM is already ready
    if (document.readyState === 'loading') {
        // DOM is still loading, wait for DOMContentLoaded
        document.addEventListener('DOMContentLoaded', executeScript);
    } else {
        // DOM is already ready, execute immediately
        executeScript();
    }
};

// Expose function to global scope for dispatcher access
window.script_func_3 = script_func_3;

const script_func_4 = () => {
    // Wait for DOM to be ready before executing
    const executeScript = () => {
// ==UserScript==
// @name        Perplexity Hide Upgrade to Max Banner
// @author      Matthew Daniel Murphy
// @description Hides the annoying Upgrade to Max reminder banner
// @version     2025.10.16.1
// @match       https://www.perplexity.ai/*
// ==/UserScript==

;(() => {
	console.log("removing banners")
	const removeBanners = () => {
		removeUpgradeToMaxBanner()
		removeUpgradeNowBanner()
		removeTryThisAnswerBanner()
	}
	const removeUpgradeToMaxBanner = () => {
		// Find the element containing "Upgrade to Max"
		const upgradeBtn = Array.from(document.querySelectorAll("div")).find((el) => el.textContent.trim() === "Upgrade to Max")

		if (!upgradeBtn) return

		// Closest ancestor with shadow-xl likely marks full banner
		const banner = upgradeBtn.closest(".shadow-xl")
		if (banner) {
			banner.remove()
		} else {
			// Fallback: Remove parent stack if .shadow-xl not found
			let parent = upgradeBtn
			for (let i = 0; i < 3; i++) {
				if (parent.parentElement & (parent.id !== "root")) parent = parent.parentElement
			}
			parent.remove()
		}
	}
	const removeUpgradeNowBanner = () => {
		// Find the element containing "Upgrade to Max"
		const upgradeBtn = Array.from(document.querySelectorAll("div")).find((el) => el.textContent.trim() === "Upgrade now")

		if (!upgradeBtn) return

		// Closest ancestor with shadow-xl likely marks full banner
		const banner = upgradeBtn.closest(".shadow-md")
		if (banner) {
			banner.remove()
		} else {
			// Fallback: Remove parent stack if .shadow-xl not found
			let parent = upgradeBtn
			for (let i = 0; i < 3; i++) {
				if (parent.parentElement & (parent.id !== "root")) parent = parent.parentElement
			}
			parent.remove()
		}
	}

	const getOwnText = (el) => {
		return Array.from(el.childNodes)
			.filter((n) => n.nodeType === Node.TEXT_NODE)
			.map((n) => n.textContent)
			.join("")
			.trim()
	}

	const removeTryThisAnswerBanner = () => {
		const target = Array.from(document.querySelectorAll("*")).find((el) => {
			const own = getOwnText(el)
			if (!own.startsWith("Try this answer with")) return false

			// ensure no descendant is a more specific match
			return !Array.from(el.querySelectorAll("*")).some((child) => getOwnText(child).startsWith("Try this answer with"))
		})

		if (target && target.parentElement && target.parentElement.parentElement) {
			target.parentElement.parentElement.remove()
		}
	}

	// Run the remover every 500ms in case the banner reappears via SPA navigation
	setInterval(removeBanners, 500)
})()

    };
    
    // Check if DOM is already ready
    if (document.readyState === 'loading') {
        // DOM is still loading, wait for DOMContentLoaded
        document.addEventListener('DOMContentLoaded', executeScript);
    } else {
        // DOM is already ready, execute immediately
        executeScript();
    }
};

// Expose function to global scope for dispatcher access
window.script_func_4 = script_func_4;

const script_func_5 = () => {
    // Wait for DOM to be ready before executing
    const executeScript = () => {
// ==UserScript==
// @name        Rate Your Music - Hide Competing Media Links
// @author      Matthew Daniel Murphy
// @description Hides competing media links on Rate Your Music when an Apple Music link is present.
// @version     1.0
// @match       *://rateyourmusic.com/*
// @grant       none
// ==/UserScript==

(() => {
    'use strict';

    const processMediaLinks = (container) => {
        const mediaLinkContainers = container.querySelectorAll('.ui_media_links_container');

        mediaLinkContainers.forEach(mediaLinkContainer => {
            const appleMusicLink = mediaLinkContainer.querySelector('.ui_media_link_btn_applemusic');

            if (appleMusicLink) {
                const allLinks = mediaLinkContainer.querySelectorAll('.ui_media_link_btn');
                allLinks.forEach(link => {
                    if (!link.classList.contains('ui_media_link_btn_applemusic')) {
                        link.remove();
                    }
                });
            }
        });
    };

    // Initial run on page load
    processMediaLinks(document.body);

    // Use a MutationObserver to handle links added dynamically
    const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
            if (mutation.addedNodes.length) {
                processMediaLinks(document.body);
            }
        });
    });

    // Start observing the entire document body for changes
    observer.observe(document.body, { childList: true, subtree: true });
})();

    };
    
    // Check if DOM is already ready
    if (document.readyState === 'loading') {
        // DOM is still loading, wait for DOMContentLoaded
        document.addEventListener('DOMContentLoaded', executeScript);
    } else {
        // DOM is already ready, execute immediately
        executeScript();
    }
};

// Expose function to global scope for dispatcher access
window.script_func_5 = script_func_5;

const script_func_6 = () => {
    // Wait for DOM to be ready before executing
    const executeScript = () => {
// ==UserScript==
// @name         YouTube Master Script (Consolidated)
// @namespace    http://tampermonkey.net/
// @version      1.0
// @description  Consolidated script for all YouTube userscript features with a single MutationObserver for efficiency.
// @author       Gemini CLI Agent
// @match        https://www.youtube.com/*
// @grant        GM.getValue
// @grant        GM.setValue
// @grant        none
// @run-at       document-start
// ==/UserScript==

;(function () {
	"use strict"

	// --- UTILITIES ---
	const isWatchPage = () => window.location.pathname === "/watch"
	const isSearchPage = () => window.location.pathname === "/results"
	const isChannelPage = () => window.location.pathname.startsWith("/@") || window.location.pathname.startsWith("/channel/")

	// --- 1. YOUTUBE REFRESH ON UNAVAILABLE VIDEO (Watch Page Only) ---
	const REFRESH_KEY = "yt_refresh_on_error_count"
	const MAX_REFRESHES = 1
	const ERROR_SELECTOR = "yt-player-error-message-renderer #reason"

	function checkAndRefresh() {
		if (!isWatchPage()) return

		const errorElement = document.querySelector(ERROR_SELECTOR)
		const isErrorPresent = errorElement && errorElement.textContent.trim() === "Video unavailable"
		let refreshCount = parseInt(localStorage.getItem(REFRESH_KEY) || "0", 10)

		if (isErrorPresent) {
			if (refreshCount < MAX_REFRESHES) {
				console.log('MasterScript: Detected "Video unavailable". Refreshing page.')
				localStorage.setItem(REFRESH_KEY, refreshCount + 1)
				window.location.reload()
			} else {
				console.log('MasterScript: Detected "Video unavailable", but max refreshes reached.')
			}
		} else {
			if (refreshCount > 0) {
				localStorage.removeItem(REFRESH_KEY)
				console.log("MasterScript: Error cleared. Resetting refresh counter.")
			}
		}
	}

	// --- 2. YOUTUBE TOGGLE THUMBNAILS ---
	let thumbnailsHidden = sessionStorage.getItem("thumbnailsHidden") === "true"
	let buttonSetup = false

	function applyThumbnailStyle(el, hide) {
		el.style.visibility = hide ? "hidden" : ""
	}

	function toggleAllThumbnails(hide) {
		document.querySelectorAll("#video-preview").forEach((videoPreview) => {
			applyThumbnailStyle(videoPreview, hide)
		})
		document.querySelectorAll("ytd-thumbnail").forEach((thumbnail) => {
			applyThumbnailStyle(thumbnail, hide)
		})
		document.querySelectorAll("yt-thumbnail-view-model").forEach((thumbnail) => {
			applyThumbnailStyle(thumbnail, hide)
		})
	}

	function isDarkMode() {
		return window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches
	}

	function setupButton(createBtn) {
		if (document.getElementById("thumbnail-toggle-btn")) return
		buttonSetup = true

		const toggleBtn = document.createElement("button")
		toggleBtn.id = "thumbnail-toggle-btn"
		toggleBtn.title = "Toggle Thumbnails"
		Object.assign(toggleBtn.style, {
			height: `${createBtn.offsetHeight}px`,
			width: `${createBtn.offsetWidth}px`,
			display: "flex",
			alignItems: "center",
			justifyContent: "center",
			background: "transparent",
			border: "none",
			cursor: "pointer",
			padding: "0",
			position: "relative",
		})

		const svgNS = "http://www.w3.org/2000/svg"
		const svg = document.createElementNS(svgNS, "svg")
		svg.setAttribute("viewBox", "0 0 24 24")
		svg.setAttribute("width", "26.4")
		svg.setAttribute("height", "26.4")
		svg.style.display = "block"

		const rect = document.createElementNS(svgNS, "rect")
		rect.setAttribute("x", "2")
		rect.setAttribute("y", "4")
		rect.setAttribute("width", "20")
		rect.setAttribute("height", "16")
		rect.setAttribute("rx", "2")
		rect.setAttribute("fill", "none")
		rect.setAttribute("stroke-width", "2")

		const sun = document.createElementNS(svgNS, "circle")
		sun.setAttribute("cx", "7")
		sun.setAttribute("cy", "9")
		sun.setAttribute("r", "2")

		const mountain = document.createElementNS(svgNS, "path")
		mountain.setAttribute("d", "M2 20 L9 13 L13 17 L17 12 L22 20 Z")

		const line = document.createElementNS(svgNS, "line")
		line.setAttribute("x1", "4")
		line.setAttribute("y1", "18")
		line.setAttribute("x2", "20")
		line.setAttribute("y2", "6")
		line.setAttribute("stroke-width", "2")
		line.setAttribute("stroke-linecap", "round")
		line.style.display = "none"

		const setIconColor = () => {
			const isDark = isDarkMode()
			const mainColor = isDark ? "#fff" : "#0f0f0f"
			const strikeColor = isDark ? "#D8D8D8" : "#252525"
			rect.setAttribute("stroke", mainColor)
			sun.setAttribute("fill", mainColor)
			mountain.setAttribute("fill", mainColor)
			mountain.setAttribute("opacity", "0.4")
			line.setAttribute("stroke", strikeColor)
		}

		svg.append(rect, sun, mountain, line)
		toggleBtn.appendChild(svg)

		toggleBtn.addEventListener("mouseenter", () => {
			if (!thumbnailsHidden) line.style.display = "block"
		})
		toggleBtn.addEventListener("mouseleave", () => {
			if (!thumbnailsHidden) line.style.display = "none"
		})
		toggleBtn.addEventListener("click", () => {
			thumbnailsHidden = !thumbnailsHidden
			sessionStorage.setItem("thumbnailsHidden", thumbnailsHidden)
			toggleAllThumbnails(thumbnailsHidden)
			line.style.display = thumbnailsHidden ? "block" : "none"
		})

		createBtn.replaceWith(toggleBtn)

		setIconColor()
		window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change", setIconColor)
	}

	function checkThumbnailButton() {
		if (buttonSetup) return
		const createBtn = document.querySelector('button[aria-label="Create"]')
		if (createBtn) {
			const parentButtonRenderer = createBtn.closest("ytd-button-renderer")
			if (parentButtonRenderer) {
				setupButton(parentButtonRenderer)
			}
		}
	}

	// --- 3. YOUTUBE REMOVE MEMBERS-ONLY VIDEOS ---
	function deleteMembersOnlyVideos() {
		// Only run on channel pages for efficiency, but keep it broad for now as the original was broad.
		// if (!isChannelPage()) return;

		const elements = Array.from(document.querySelectorAll("p")).filter((el) => el.textContent.trim() === "Members only")

		elements.forEach((el) => {
			const videoItem = el.closest("ytd-rich-item-renderer, ytd-grid-video-renderer, ytd-video-renderer")
			if (videoItem) {
				videoItem.remove()
			}
		})
	}

	// --- 4. YOUTUBE HIDE SHORTS ---
	function removeShortsRows() {
		const shortsRows = Array.from(document.querySelectorAll("ytd-rich-section-renderer, ytd-rich-shelf-renderer")).filter((el) => el.textContent && /Shorts/i.test(el.textContent))

		if (shortsRows.length > 0) {
			shortsRows.forEach((row) => row.remove())
			return true
		}
		return false
	}

	function removeShortsSearchGrid() {
		const shortsSpans = Array.from(document.querySelectorAll("span")).filter((span) => span.innerText === "Shorts")
		let removed = false
		shortsSpans.forEach((span) => {
			const shelf = span.closest("grid-shelf-view-model")
			if (shelf) {
				shelf.remove()
				removed = true
			}
		})
		return removed
	}

	function runShortsRemovers() {
		removeShortsRows()
		removeShortsSearchGrid()
	}

	// --- 5. YOUTUBE GET TRANSCRIPT BUTTON (Watch Page Only) ---
	let _transcriptInterval = null

	async function setupTranscriptButton() {
		if (!isWatchPage()) return

		const shareBtnContainer = document.querySelector("#above-the-fold #top-level-buttons-computed")
		if (!shareBtnContainer || shareBtnContainer.children.length < 2) {
			return
		}
		const shareBtn = shareBtnContainer.children[1].querySelector('button[aria-label="Share"]')

		if (!shareBtn || shareBtn.hasAttribute("data-transcript-button-processed")) {
			return
		}

		shareBtn.setAttribute("data-transcript-button-processed", "true")

		// Change button text
		const textDiv = shareBtn.querySelector(".yt-spec-button-shape-next__button-text-content")
		if (textDiv) {
			textDiv.innerText = "Get transcript"
		} else {
			shareBtn.innerText = "Get transcript"
		}

		// Set click handler (keeping the async logic)
		shareBtn.onclick = async function () {
			const showTranscriptBtn = document.querySelector('button[aria-label="Show transcript"]')
			if (showTranscriptBtn) {
				showTranscriptBtn.click()
			} else {
				alert('No "Show transcript" button found!')
				return
			}

			let maxTries = 200,
				tries = 0
			let transcriptContainer = null
			while (!transcriptContainer && tries < maxTries) {
				await new Promise((res) => setTimeout(res, 20))
				transcriptContainer = document.querySelector("#segments-container")
				tries++
			}
			if (!transcriptContainer) {
				alert("Transcript container not found!")
				return
			}

			let lines = transcriptContainer.innerText.split("\n")
			let processed = []
			let lastTime = null
			const timecodeRegex = /^(?:\d{1,2}:)?\d{2}$/
			const audioDescRegex = /^\[.*\]$/

			for (let i = 0; i < lines.length; i++) {
				const line = lines[i].trim()
				if (line === "") continue

				if (!isNaN(Number(line.replace(":", ""))) && timecodeRegex.test(line)) {
					lastTime = line
					if (lines[i + 1] && audioDescRegex.test(lines[i + 1].trim())) {
						i++
						lastTime = null
					}
				} else if (audioDescRegex.test(line)) {
					lastTime = null
					continue
				} else if (lastTime) {
					processed.push(`[${lastTime}] ${line}`)
					lastTime = null
				} else {
					processed.push(line)
				}
			}

			const finalTranscript = processed.join("\n").replace(/\n{3,}/g, "\n\n")
			const transcriptPanel = transcriptContainer.closest("ytd-engagement-panel-section-list-renderer")

			try {
				transcriptPanel.querySelector("#visibility-button button").click()
			} catch (err) {
				console.log("Failed to close panel:", err)
			}

			try {
				await navigator.clipboard.writeText(finalTranscript)
				alert("Transcript copied to clipboard!")
			} catch (err) {
				alert("Failed to copy transcript: " + err)
			}
		}
	}

	// --- 6. YOUTUBE SEARCH EXCLUDE TERMS (Search Page Only) ---
	let resultsObserver = null
	let _ytExclResizeHandler = null
	let _ytExclScrollHandler = null

	function ensureStyle() {
		let style = document.getElementById("yt-search-exclusion-style")
		if (style) return style
		style = document.createElement("style")
		style.id = "yt-search-exclusion-style"
		style.appendChild(document.createTextNode('ytd-video-renderer[data-excluded="true"] { display: none !important; }\n            #yt-search-exclusion-tip { will-change: transform, opacity; }'))
		document.head.appendChild(style)
		return style
	}

	function ensureTooltip() {
		let tip = document.getElementById("yt-search-exclusion-tip")
		if (tip) return tip

		tip = document.createElement("div")
		tip.id = "yt-search-exclusion-tip"
		tip.setAttribute("role", "tooltip")

		Object.assign(tip.style, {
			position: "absolute",
			zIndex: "9999",
			maxWidth: "320px",
			background: "rgba(28,28,28,0.96)",
			color: "#fff",
			padding: "6px 8px",
			borderRadius: "8px",
			boxShadow: "0 6px 16px rgba(0,0,0,0.35)",
			fontSize: "12px",
			lineHeight: "14px",
			height: "14px",
			pointerEvents: "none",
			transition: "opacity 120ms ease",
			opacity: "0",
			backdropFilter: "blur(6px)",
			border: "1px solid rgba(255,255,255,0.1)",
			whiteSpace: "nowrap",
		})

		const span = document.createElement("span")
		span.textContent = "Omit terms using dashes. Example: pizza -shorts -trailer"
		tip.appendChild(span)

		document.body.appendChild(tip)
		return tip
	}

	function getSearchInput() {
		let input = document.querySelector('input[name="search_query"]') || document.querySelector('input[role="combobox"][placeholder="Search"]')
		if (!input) {
			const candidates = Array.from(document.querySelectorAll('input[type="text"], input'))
			input =
				candidates.find((el) => {
					const ph = (el.getAttribute("placeholder") || "").toLowerCase()
					const role = (el.getAttribute("role") || "").toLowerCase()
					const name = (el.getAttribute("name") || "").toLowerCase()
					return role === "combobox" || name === "search_query" || ph.includes("search")
				}) || null
		}
		return input
	}

	function getSuggestionsListbox() {
		return document.querySelector('[role="listbox"]')
	}

	function showTooltipNear(input) {
		const tip = ensureTooltip()
		const rect = input.getBoundingClientRect()
		const scrollX = window.scrollX || document.documentElement.scrollLeft || 0
		const scrollY = window.scrollY || document.documentElement.scrollTop || 0
		const margin = 8
		const extraLeft = 50
		const extraTop = 5

		tip.style.left = "-9999px"
		tip.style.top = "-9999px"
		tip.style.opacity = "0"
		const tipRectInitial = tip.getBoundingClientRect()

		let left = rect.left + scrollX - tipRectInitial.width - margin - extraLeft
		let top = rect.top + scrollY + extraTop

		if (left < scrollX + 8) {
			left = rect.left + scrollX - extraLeft
			top = rect.top + scrollY - tipRectInitial.height - margin + extraTop
			if (top < scrollY + 8) {
				top = rect.bottom + scrollY + margin + extraTop
			}
		}

		tip.style.left = `${left}px`
		tip.style.top = `${top}px`
		tip.style.opacity = "1"

		const listbox = getSuggestionsListbox()
		if (listbox) {
			listbox.style.transform = `translateY(30px)`
			listbox.style.willChange = "transform"
		}
	}

	function hideTooltip() {
		const tip = document.getElementById("yt-search-exclusion-tip")
		if (tip) tip.style.opacity = "0"
		const listbox = getSuggestionsListbox()
		if (listbox) {
			listbox.style.transform = ""
			listbox.style.willChange = ""
		}
	}

	function parseExclusions(query) {
		if (!query) return []
		const tokens = String(query).split(/\s+/).filter(Boolean)
		const excl = tokens
			.filter((t) => t.startsWith("-"))
			.map((t) => {
				const stripped = t.replace(/^-/, "")
				if (!stripped || stripped.startsWith("-")) return ""
				return stripped.trim().toLowerCase()
			})
			.filter(Boolean)
		return Array.from(new Set(excl))
	}

	function getTitleText(videoRenderer) {
		if (!videoRenderer) return ""
		let a = videoRenderer.querySelector("a#video-title")
		if (!a) {
			a =
				videoRenderer.querySelector("h3 a[aria-label], h3 a[title]") ||
				videoRenderer.querySelector('a[aria-label][href*="/watch"], a[title][href*="/watch"]') ||
				videoRenderer.querySelector('a[href*="/watch"]')
		}
		if (!a) return ""
		const ytf = a.querySelector("yt-formatted-string")
		const text = (ytf ? ytf.textContent : a.textContent) || ""
		return text.trim()
	}

	function applyExclusionToRenderer(renderer, exclusions) {
		const title = getTitleText(renderer).toLowerCase()
		if (!title) {
			renderer.removeAttribute("data-excluded")
			return false
		}
		const matched = exclusions.some((kw) => title.includes(kw))
		if (matched) {
			renderer.setAttribute("data-excluded", "true")
			return true
		} else {
			renderer.removeAttribute("data-excluded")
			return false
		}
	}

	function getExclusionsFromURL() {
		const urlParams = new URLSearchParams(window.location.search)
		const searchQuery = urlParams.get("search_query") || ""
		return parseExclusions(searchQuery)
	}

	function applySearchFilter(exclusions) {
		const renderers = Array.from(document.querySelectorAll("ytd-video-renderer"))
		for (const r of renderers) {
			applyExclusionToRenderer(r, exclusions)
		}
	}

	function initSearchExclusion() {
		if (!isSearchPage()) return

		ensureStyle()
		const input = getSearchInput()
		if (!input) return

		let currentExclusions = getExclusionsFromURL()
		let userHasModifiedInput = false

		applySearchFilter(currentExclusions)

		let typingTimer = null
		const reapply = () => {
			if (userHasModifiedInput) {
				currentExclusions = parseExclusions(input.value)
			} else {
				const urlExclusions = getExclusionsFromURL()
				const inputExclusions = parseExclusions(input.value)
				currentExclusions = urlExclusions.length > 0 ? urlExclusions : inputExclusions
			}
			applySearchFilter(currentExclusions)
		}
		const debouncedReapply = () => {
			if (typingTimer) clearTimeout(typingTimer)
			typingTimer = setTimeout(reapply, 500)
		}

		// Remove previous handlers if pasted multiple times (important for SPA navigation)
		input.removeEventListener("focus", input._ytExclFocusHandler || (() => {}))
		input.removeEventListener("click", input._ytExclClickHandler || (() => {}))
		input.removeEventListener("blur", input._ytExclBlurHandler || (() => {}))
		input.removeEventListener("input", input._ytExclInputHandler || (() => {}))
		input.removeEventListener("change", input._ytExclChangeHandler || (() => {}))
		input.removeEventListener("keyup", input._ytExclKeyupHandler || (() => {}))
		const form = input.closest("form")
		if (form) {
			form.removeEventListener("submit", input._ytExclSubmitHandler || (() => {}))
		}

		// Handlers
		input._ytExclFocusHandler = () => showTooltipNear(input)
		input._ytExclClickHandler = () => showTooltipNear(input)
		input._ytExclBlurHandler = () => hideTooltip()
		input._ytExclInputHandler = () => {
			userHasModifiedInput = true
			debouncedReapply()
		}
		input._ytExclChangeHandler = () => {
			userHasModifiedInput = true
			debouncedReapply()
		}
		input._ytExclKeyupHandler = () => {
			userHasModifiedInput = true
			debouncedReapply()
		}

		input.addEventListener("focus", input._ytExclFocusHandler)
		input.addEventListener("click", input._ytExclClickHandler)
		input.addEventListener("blur", input._ytExclBlurHandler)
		input.addEventListener("input", input._ytExclInputHandler)
		input.addEventListener("change", input._ytExclChangeHandler)
		input.addEventListener("keyup", input._ytExclKeyupHandler)

		if (form) {
			input._ytExclSubmitHandler = () => setTimeout(reapply, 600)
			form.addEventListener("submit", input._ytExclSubmitHandler)
		}

		const tip = ensureTooltip()
		const reposition = () => {
			if (tip.style.opacity === "1") showTooltipNear(input)
		}
		window.removeEventListener("resize", _ytExclResizeHandler || (() => {}))
		window.removeEventListener("scroll", _ytExclScrollHandler || (() => {}))
		_ytExclResizeHandler = reposition
		_ytExclScrollHandler = reposition
		window.addEventListener("resize", _ytExclResizeHandler, { passive: true })
		window.addEventListener("scroll", _ytExclScrollHandler, { passive: true })
	}

	// --- 7. YOUTUBE MAX QUALITY (Event-based) ---
	// Full content of youtube-max-quality.js, adapted to fit the master script's IIFE.

	const DEBUG = false
	const resolutions = ["highres", "hd2880", "hd2160", "hd1440", "hd1080", "hd720", "large", "medium", "small", "tiny"]
	const heights = [4320, 2880, 2160, 1440, 1080, 720, 480, 360, 240, 144]
	let doc = document,
		win = window
	let recentVideo = ""
	let foundHFR = false
	let setHeight = 0
	let maxQualitySettings = {}

	function debugLog(message) {
		if (DEBUG) {
			console.log("YTHD | " + message)
		}
	}

	function unwrapElement(el) {
		if (el && el.wrappedJSObject) {
			return el.wrappedJSObject
		}
		return el
	}

	function getPlayer() {
		let ytPlayer = doc.getElementById("movie_player") || doc.getElementsByClassName("html5-video-player")[0]
		return unwrapElement(ytPlayer)
	}

	function getVideoIDFromURL(ytPlayer) {
		const idMatch = /(?:v=)([\\w\\-]+)/
		let id = "ERROR: idMatch failed; youtube changed something"
		let matches = idMatch.exec(ytPlayer.getVideoUrl())
		if (matches) {
			id = matches[1]
		}
		return id
	}

	function setResolution(ytPlayer, resolutionList) {
		debugLog("Setting Resolution...")

		const currentQuality = ytPlayer.getPlaybackQuality()
		let res = maxQualitySettings.targetRes

		if (maxQualitySettings.highFramerateTargetRes && foundHFR) {
			res = maxQualitySettings.highFramerateTargetRes
		}

		let shouldPremium = maxQualitySettings.preferPremium && [...ytPlayer.getAvailableQualityData()].some((q) => q.quality == res && q.qualityLabel.includes("Premium") && q.isPlayable)
		let useButtons = !maxQualitySettings.useAPI || shouldPremium

		if (resolutionList.indexOf(res) < resolutionList.indexOf(currentQuality)) {
			const end = resolutionList.length - 1
			let nextBestIndex = Math.max(resolutionList.indexOf(res), 0)
			let ytResolutions = ytPlayer.getAvailableQualityLevels()
			debugLog("Available Resolutions: " + ytResolutions.join(", "))

			while (ytResolutions.indexOf(resolutionList[nextBestIndex]) === -1 && nextBestIndex < end) {
				++nextBestIndex
			}

			if (!useButtons && maxQualitySettings.flushBuffer && currentQuality !== resolutionList[nextBestIndex]) {
				let id = getVideoIDFromURL(ytPlayer)
				if (id.indexOf("ERROR") === -1) {
					let pos = ytPlayer.getCurrentTime()
					ytPlayer.loadVideoById(id, pos, resolutionList[nextBestIndex])
				}
				debugLog("ID: " + id)
			}
			res = resolutionList[nextBestIndex]
		}

		if (maxQualitySettings.useAPI) {
			if (ytPlayer.setPlaybackQualityRange !== undefined) {
				ytPlayer.setPlaybackQualityRange(res)
			}
			ytPlayer.setPlaybackQuality(res)
			debugLog("(API) Resolution Set To: " + res)
		}
		if (useButtons) {
			let resLabel = heights[resolutionList.indexOf(res)]
			if (shouldPremium) {
				resLabel = [...ytPlayer.getAvailableQualityData()].find((q) => q.quality == res && q.qualityLabel.includes("Premium")).qualityLabel
			}

			let settingsButton = doc.querySelector(".ytp-settings-button:not(#ScaleBtn)")
			if (settingsButton) unwrapElement(settingsButton).click()

			let qualityMenuButton = document.evaluate(
				'.//*[contains(text(),"Quality")]/ancestor-or-self::*[@class="ytp-menuitem-label"]',
				ytPlayer,
				null,
				XPathResult.FIRST_ORDERED_NODE_TYPE,
				null
			).singleNodeValue
			if (qualityMenuButton) unwrapElement(qualityMenuButton).click()

			let qualityButton = document.evaluate(
				'.//*[contains(text(),"' + heights[resolutionList.indexOf(res)] + '") and not(@class)]/ancestor::*[@class="ytp-menuitem"]',
				ytPlayer,
				null,
				XPathResult.FIRST_ORDERED_NODE_TYPE,
				null
			).singleNodeValue
			if (qualityButton) unwrapElement(qualityButton).click()
			debugLog("(Buttons) Resolution Set To: " + res)
		}
	}

	function setResOnReady(ytPlayer, resolutionList) {
		if (maxQualitySettings.useAPI && (ytPlayer.getPlaybackQuality === undefined || ytPlayer.getPlaybackQuality() == "unknown")) {
			win.setTimeout(setResOnReady, 100, ytPlayer, resolutionList)
		} else {
			let framerateUpdate = false
			if (maxQualitySettings.highFramerateTargetRes) {
				let features = ytPlayer.getVideoData().video_quality_features
				if (features) {
					let isHFR = features.includes("hfr")
					framerateUpdate = isHFR && !foundHFR
					foundHFR = isHFR
				}
			}

			let curVid = getVideoIDFromURL(ytPlayer)
			if (curVid !== recentVideo || framerateUpdate) {
				recentVideo = curVid
				setResolution(ytPlayer, resolutionList)

				let storedQuality = localStorage.getItem("yt-player-quality")
				if (!storedQuality || storedQuality.indexOf(maxQualitySettings.targetRes) === -1) {
					let tc = Date.now(),
						te = tc + 2592000000
					localStorage.setItem("yt-player-quality", '{"data":"' + maxQualitySettings.targetRes + '","expiration":' + te + ',"creation":' + tc + "}")
				}
			}
		}
	}

	function setTheaterMode(ytPlayer) {
		debugLog("Setting Theater Mode")

		if (win.location.href.indexOf("/watch") !== -1) {
			let pageManager = unwrapElement(doc.getElementsByTagName("ytd-watch-flexy")[0])

			if (pageManager && !pageManager.hasAttribute("theater")) {
				if (maxQualitySettings.enableErrorScreenWorkaround) {
					const styleContent = "#error-screen { z-index: 42 !important } .ytp-error { display: none !important }"

					let errorStyle = doc.getElementById("ythdErrorWorkaroundStyleSheet")
					if (!errorStyle) {
						errorStyle = doc.createElement("style")
						errorStyle.type = "text/css"
						errorStyle.id = "ythdStyleSheet"
						errorStyle.textContent = styleContent
						doc.head.appendChild(errorStyle)
					} else {
						errorStyle.textContent = styleContent
					}
				}

				try {
					pageManager.setTheaterModeRequested(true)
					pageManager.updateTheaterModeState_(true)
					pageManager.onTheaterReduxValueUpdate(true)
					pageManager.setPlayerTheaterMode_()
					pageManager.dispatchEvent(new CustomEvent("yt-set-theater-mode-enabled", { detail: { enabled: true }, bubbles: true, cancelable: false }))
				} catch {}

				let theaterButton
				for (let i = 0; i < 3 && !pageManager.theaterValue; ++i) {
					debugLog("Clicking theater button to attempt to notify redux state")
					theaterButton = theaterButton || unwrapElement(doc.getElementsByClassName("ytp-size-button")[0])
					if (theaterButton) theaterButton.click()
				}
			}
		}
	}

	function computeAndSetPlayerSize() {
		let height = maxQualitySettings.customHeight
		if (!maxQualitySettings.useCustomSize) {
			let heightOffsetEl = doc.getElementById("masthead")
			let mastheadContainerEl = doc.getElementById("masthead-container")
			let mastheadHeight = 50,
				mastheadPadding = 16
			if (heightOffsetEl && mastheadContainerEl) {
				mastheadHeight = parseInt(win.getComputedStyle(heightOffsetEl).height, 10)
				mastheadPadding = parseInt(win.getComputedStyle(mastheadContainerEl).paddingBottom, 10) * 2
			}

			let i = Math.max(resolutions.indexOf(maxQualitySettings.targetRes), 0)
			height = Math.min(heights[i], win.innerHeight - (mastheadHeight + mastheadPadding))
			height = Math.max(height, 270)

			if (maxQualitySettings.removeBlackBars) {
				let ytPlayer = getPlayer()
				if (ytPlayer !== undefined && ytPlayer.getVideoAspectRatio !== undefined) {
					height = Math.min(height, win.innerWidth / ytPlayer.getVideoAspectRatio())
				}
			}
		}
		resizePlayer(height)
	}

	function resizePlayer(height) {
		debugLog("Setting video player size to " + height)

		if (setHeight === height) {
			debugLog("Player size already set")
			return
		}

		let styleContent =
			"\
ytd-watch-flexy[theater]:not([fullscreen]) #player-theater-container.style-scope, \
ytd-watch-flexy[theater]:not([fullscreen]) #player-wide-container.style-scope, \
ytd-watch-flexy[theater]:not([fullscreen]) #full-bleed-container.style-scope { \
min-height: " +
			height +
			"px !important; max-height: none !important; height: " +
			height +
			"px !important }"

		let ythdStyle = doc.getElementById("ythdStyleSheet")
		if (!ythdStyle) {
			ythdStyle = doc.createElement("style")
			ythdStyle.type = "text/css"
			ythdStyle.id = "ythdStyleSheet"
			ythdStyle.textContent = styleContent
			doc.head.appendChild(ythdStyle)
		} else {
			ythdStyle.textContent = styleContent
		}

		setHeight = height
		win.dispatchEvent(new Event("resize"))
	}

	function initMaxQuality() {
		if (!isWatchPage()) return

		let ytPlayer = getPlayer()

		if (maxQualitySettings.autoTheater && ytPlayer) {
			if (maxQualitySettings.allowCookies && doc.cookie.indexOf("wide=1") === -1) {
				doc.cookie = "wide=1; domain=.youtube.com"
			}
			setTheaterMode(ytPlayer)
		}

		if (maxQualitySettings.changePlayerSize && win.location.host.indexOf("youtube.com") !== -1 && win.location.host.indexOf("gaming.") === -1) {
			computeAndSetPlayerSize()
			window.addEventListener("resize", computeAndSetPlayerSize, true)
		}

		if (maxQualitySettings.changeResolution && maxQualitySettings.setResolutionEarly && ytPlayer) {
			setResOnReady(ytPlayer, resolutions)
		}

		if (maxQualitySettings.changeResolution || maxQualitySettings.autoTheater) {
			win.addEventListener(
				"loadstart",
				function (e) {
					if (!(e.target instanceof win.HTMLMediaElement)) {
						return
					}
					ytPlayer = getPlayer()
					if (ytPlayer) {
						debugLog("Loaded new video")
						if (maxQualitySettings.changeResolution) {
							setResOnReady(ytPlayer, resolutions)
						}
						if (maxQualitySettings.autoTheater) {
							setTheaterMode(ytPlayer)
						}
					}
				},
				true
			)
		}
	}

	async function applyMaxQualitySettings() {
		// Default settings from the original script
		maxQualitySettings = {
			changeResolution: true,
			preferPremium: true,
			targetRes: "hd2160",
			highFramerateTargetRes: null,
			changePlayerSize: false,
			removeBlackBars: false,
			useCustomSize: false,
			customHeight: 600,
			autoTheater: false,
			flushBuffer: true,
			allowCookies: false,
			setResolutionEarly: true,
			enableErrorScreenWorkaround: true,
			useAPI: true,
			overwriteStoredSettings: false,
		}

		if (typeof GM != "undefined" && GM.getValue && GM.setValue) {
			let settingsSaved = await GM.getValue("SettingsSaved")

			if (maxQualitySettings.overwriteStoredSettings || !settingsSaved) {
				Object.entries(maxQualitySettings).forEach(([k, v]) => GM.setValue(k, v))
				await GM.setValue("SettingsSaved", true)
			} else {
				await Promise.all(
					Object.keys(maxQualitySettings).map((k) => {
						let newval = GM.getValue(k)
						return newval.then((v) => [k, v])
					})
				).then((c) =>
					c.forEach(([nk, nv]) => {
						if (maxQualitySettings[nk] !== null && nk !== "overwriteStoredSettings") {
							maxQualitySettings[nk] = nv
						}
					})
				)
			}
			debugLog(
				Object.entries(maxQualitySettings)
					.map(([k, v]) => k + " | " + v)
					.join(", ")
			)
		}
	}

	// --- 8. IGNORE NUMBER KEYS (Prevent accidental seeking) ---
	function setupIgnoreNumberKeys() {
		window.addEventListener(
			"keydown",
			(e) => {
				if (isWatchPage() && /^\d$/.test(e.key) && !e.ctrlKey && !e.altKey && !e.metaKey) {
					const activeElement = document.activeElement
					const isInput =
						activeElement && (activeElement.tagName === "INPUT" || activeElement.tagName === "TEXTAREA" || activeElement.isContentEditable || activeElement.getAttribute("role") === "textbox")

					if (!isInput) {
						e.stopPropagation()
						e.stopImmediatePropagation()
						e.preventDefault()
					}
				}
			},
			true
		)
	}

	// --- MASTER MUTATION HANDLER ---

	/**
	 * The single callback function for the MutationObserver.
	 * It runs all necessary DOM-based checks.
	 */
	function masterMutationHandler() {
		// 1. Thumbnail Toggle (Check for button and hide new thumbnails)
		checkThumbnailButton()
		if (thumbnailsHidden) {
			toggleAllThumbnails(true)
		}

		// 2. Remove Members-Only Videos
		deleteMembersOnlyVideos()

		// 3. Hide Shorts
		runShortsRemovers()

		// 4. Refresh on Error (Watch Page)
		checkAndRefresh()

		// 5. Search Exclusion (Search Page)
		if (isSearchPage()) {
			// Re-apply filter to newly loaded results
			const input = getSearchInput()
			if (input) {
				const currentExclusions = parseExclusions(input.value)
				applySearchFilter(currentExclusions)
			}
		}
	}

	// --- INITIALIZATION ---

	function initPageFeatures() {
		// Stop any previous intervals/listeners that are page-specific
		if (_transcriptInterval) {
			clearInterval(_transcriptInterval)
			_transcriptInterval = null
		}
		if (resultsObserver) {
			resultsObserver.disconnect()
			resultsObserver = null
		}
		hideTooltip() // Hide any lingering tooltip

		// Run initial checks for all features
		masterMutationHandler()

		// Setup URL-specific features
		if (isSearchPage()) {
			initSearchExclusion()
		}

		if (isWatchPage()) {
			// Start Max Quality script (event-based logic)
			initMaxQuality()

			// Start Transcript Button polling (needs polling to wait for button to appear)
			if (!_transcriptInterval) {
				_transcriptInterval = setInterval(setupTranscriptButton, 500)
			}
		}
	}

	// 1. Initial setup for features that need to run immediately
	toggleAllThumbnails(thumbnailsHidden) // Initial thumbnail state

	// 2. Start the single MutationObserver
	const masterObserver = new MutationObserver(masterMutationHandler)
	masterObserver.observe(document.documentElement, { childList: true, subtree: true })

	// 3. Handle SPA navigation (yt-navigate-finish is the best event for this)
	window.addEventListener("yt-navigate-finish", initPageFeatures, true)

	// 4. Setup keyboard overrides
	setupIgnoreNumberKeys()

	// 5. Apply Max Quality settings and run initial page features
	applyMaxQualitySettings().then(() => {
		initPageFeatures()
	})
})()

    };
    
    // Check if DOM is already ready
    if (document.readyState === 'loading') {
        // DOM is still loading, wait for DOMContentLoaded
        document.addEventListener('DOMContentLoaded', executeScript);
    } else {
        // DOM is already ready, execute immediately
        executeScript();
    }
};

// Expose function to global scope for dispatcher access
window.script_func_6 = script_func_6;


// Execution Dispatcher - Wait for DOM ready before URL matching
(function() {
    'use strict';
    
    
    /**
     * Simple pattern matching function
     * Checks if window.location.href contains the pattern string
     * @param {string} pattern - The pattern to match against the URL
     * @returns {boolean} - True if pattern is found in URL
     */
    function matchesPattern(pattern) {
        return pattern === '*' || window.location.href.includes(pattern);
    }
    
    /**
     * Execute the dispatcher logic
     */
    function executeDispatcher() {
        // Processed manifest array with function names
        const processedManifest = [
    {
        "functionName": "script_func_0",
        "match": "1337x.to",
        "originalFile": "1337x.js",
        "name": "Auto Focus 1337x Search"
    },
    {
        "functionName": "script_func_1",
        "match": "www.perplexity.ai",
        "originalFile": "Perplexity.ai Improvements.user.js",
        "name": "Perplexity.ai Improvements"
    },
    {
        "functionName": "script_func_2",
        "match": "www.amazon.ca",
        "originalFile": "amazon filter.js",
        "name": "Amazon Filter"
    },
    {
        "functionName": "script_func_3",
        "match": "*",
        "originalFile": "open-apple-music-links-in-music-app.js",
        "name": "Open Apple Music links in Music App"
    },
    {
        "functionName": "script_func_4",
        "match": "www.perplexity.ai",
        "originalFile": "perplexity hide Upgrade to Max banner.js",
        "name": "Perplexity Hide Upgrade to Max Banner"
    },
    {
        "functionName": "script_func_5",
        "match": "rateyourmusic.com",
        "originalFile": "rate-your-music-hide-competing-media.js",
        "name": "Rate Your Music - Hide Competing Media Links"
    },
    {
        "functionName": "script_func_6",
        "match": "www.youtube.com",
        "originalFile": "youtube-master.user.js",
        "name": "YouTube Master Script (Consolidated)"
    }
];
        
        
        // Iterate over manifest and execute matching scripts
        processedManifest.forEach((entry, index) => {
            try {
                const urlMatches = matchesPattern(entry.match);
                
                if (urlMatches) {
                    console.log(`"${entry.name}" script loaded because it matches the URL pattern "${entry.match}"`);
                    
                    // Call the corresponding function
                    if (typeof window[entry.functionName] === 'function') {
                        window[entry.functionName]();
                    } else {
                        console.error(` Function ${entry.functionName} not found or not callable`);
                    }
                }
            } catch (error) {
                console.error(` Error executing "${entry.name}" (${entry.functionName}):`, error);
            }
        });
        
    }
    
    // Wait for DOM to be ready before executing dispatcher
    if (document.readyState === 'loading') {
        // DOM is still loading, wait for DOMContentLoaded
        document.addEventListener('DOMContentLoaded', executeDispatcher);
    } else {
        // DOM is already ready, execute immediately
        executeDispatcher();
    }
})();
