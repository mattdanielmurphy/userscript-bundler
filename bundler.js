#!/usr/bin/env node

/**
 * Userscript Bundler
 *
 * This Node.js script automates the creation of a single, CSP-safe JavaScript file
 * (userscript_bundle.js) which will be loaded by a userscript manager (like Tampermonkey)
 * via a single local @require line. The bundled file contains logic to check the current
 * page URL and conditionally execute code from separate source files.
 */

const fs = require("fs")
const path = require("path")

// Constants
const MANIFEST_FILE = "script_manifest.json"
const OUTPUT_FILE = "userscript_bundle.js"
const SOURCE_DIR = "./"
const USERSCRIPTS_DIR = "./userscripts/"

/**
 * Parse userscript header to extract @name and @match information
 * @param {string} filePath - Path to the userscript file
 * @returns {Object|null} - Object with name, match, and file properties, or null if parsing fails
 */
function parseUserscriptHeader(filePath) {
	try {
		const content = fs.readFileSync(filePath, "utf8")
		const lines = content.split("\n")

		let name = null
		let matches = []
		let inHeader = false

		for (const line of lines) {
			const trimmedLine = line.trim()

			// Check for start of userscript header
			if (trimmedLine === "// ==UserScript==") {
				inHeader = true
				continue
			}

			// Check for end of userscript header
			if (trimmedLine === "// ==/UserScript==") {
				break
			}

			// Parse header directives
			if (inHeader) {
				const nameMatch = trimmedLine.match(/^\/\/\s*@name\s+(.+)$/)
				if (nameMatch) {
					name = nameMatch[1].trim()
					continue
				}

				const matchMatch = trimmedLine.match(/^\/\/\s*@match\s+(.+)$/)
				if (matchMatch) {
					const matchPattern = matchMatch[1].trim()

					// Extract domain from match pattern for simpler matching
					let domain = null
					if (matchPattern === "*://*/*") {
						domain = "*"
					} else {
						const domainMatch = matchPattern.match(/(?:https?|\*):\/\/(?:\*\.)?([^\/\*]+)/)
						if (domainMatch) {
							domain = domainMatch[1]
						}
					}

					if (domain) {
						matches.push(domain)
					}
					continue
				}
			}
		}

		if (name && matches.length > 0) {
			return {
				name: name,
				match: matches[0], // Keep for backward compatibility if needed
				matches: matches,
				file: path.basename(filePath),
			}
		}

		return null
	} catch (error) {
		console.warn(`‚ö†Ô∏è  Error parsing userscript header for ${filePath}:`, error.message)
		return null
	}
}

/**
 * Auto-generate manifest from userscript files
 * @returns {Array} - Array of manifest entries
 */
function generateManifestFromUserscripts() {
	console.log(`üîç Scanning userscripts directory: ${USERSCRIPTS_DIR}`)

	if (!fs.existsSync(USERSCRIPTS_DIR)) {
		throw new Error(`Userscripts directory not found: ${USERSCRIPTS_DIR}`)
	}

	const files = fs.readdirSync(USERSCRIPTS_DIR)
	const jsFiles = files.filter((file) => file.endsWith(".js") && !file.includes(".disabled."))

	if (jsFiles.length === 0) {
		throw new Error(`No JavaScript files found in ${USERSCRIPTS_DIR}`)
	}

	console.log(`üìÅ Found ${jsFiles.length} JavaScript files: ${jsFiles.join(", ")}`)

	const manifest = []

	for (const file of jsFiles) {
		const filePath = path.join(USERSCRIPTS_DIR, file)
		console.log(`üìã Parsing userscript: ${file}`)

		const parsed = parseUserscriptHeader(filePath)
		if (parsed) {
			manifest.push({
				file: parsed.file,
				matches: parsed.matches,
				name: parsed.name,
			})
			console.log(`‚úÖ Parsed: "${parsed.name}" -> matches [${parsed.matches.join(", ")}]`)
		} else {
			console.warn(`‚ö†Ô∏è  Could not parse userscript header for: ${file}`)
		}
	}

	if (manifest.length === 0) {
		throw new Error("No valid userscripts found with proper @name and @match headers")
	}

	console.log(`üìä Generated manifest with ${manifest.length} entries`)
	return manifest
}

/**
 * Main bundler function
 */
async function bundleUserscripts() {
	try {
		console.log("üöÄ Starting userscript bundling process...")

		// Step 1: Auto-generate manifest from userscript files
		console.log("üìã Auto-generating manifest from userscript files...")
		const manifest = generateManifestFromUserscripts()

		console.log(`‚úÖ Generated manifest with ${manifest.length} script entries`)

		// Step 2: Initialize code bundle string
		let bundleCode = ""
		bundleCode += "// Userscript Bundle - Auto-generated by bundler.js\n"
		const generationDate = new Date().toISOString()
		bundleCode += "// Generated on: " + generationDate + "\n\n"

		const buildId = Date.now().toString()

		bundleCode += `
console.log("üì¶ [Bundler] Userscript Bundle Loaded! (Build: ${buildId})");
try {
const __BUILD_ID__ = "${buildId}";

`

		// Step 3: Iterative wrapping - process each manifest entry
		const processedManifest = []

		for (let i = 0; i < manifest.length; i++) {
			const entry = manifest[i]

			if (!entry.file || !entry.matches) {
				console.warn(`‚ö†Ô∏è  Skipping invalid manifest entry at index ${i}: missing file or match property`)
				continue
			}

			console.log(`üì¶ Processing script ${i + 1}/${manifest.length}: ${entry.file}`)

			// Generate unique, safe function name
			const functionName = `script_func_${i}`

			// Read source file content
			const sourcePath = path.join(USERSCRIPTS_DIR, entry.file)

			if (!fs.existsSync(sourcePath)) {
				console.warn(`‚ö†Ô∏è  Source file not found: ${sourcePath}, skipping...`)
				continue
			}

			const sourceContent = fs.readFileSync(sourcePath, "utf8")

			// Wrap content into function definition template with DOM ready logic
			const wrappedFunction = `const ${functionName} = () => {
    // Wait for DOM to be ready before executing
    const executeScript = () => {
${sourceContent}
    };
    
    // Check if DOM is already ready
    if (document.readyState === 'loading') {
        // DOM is still loading, wait for DOMContentLoaded
        document.addEventListener('DOMContentLoaded', executeScript);
    } else {
        // DOM is already ready, execute immediately
        executeScript();
    }
};

// Expose function to global scope for dispatcher access
window.${functionName} = ${functionName};

`

			// Append wrapped function to bundle
			bundleCode += wrappedFunction

			// Update processed manifest with function name
			processedManifest.push({
				functionName: functionName,
				matches: entry.matches,
				originalFile: entry.file,
				name: entry.name,
			})

			console.log(`‚úÖ Wrapped ${entry.file} as ${functionName}`)
		}

		// Step 4: Append execution logic (Dispatcher)
		console.log("üîß Adding execution dispatcher...")

		const dispatcherCode = `
// Execution Dispatcher - Wait for DOM ready before URL matching
(function() {
    'use strict';
    
    
    /**
     * Simple pattern matching function
     * Checks if window.location.href contains any of the pattern strings in the array
     * @param {Array} matchPatterns - The patterns to match against the URL
     * @returns {boolean} - True if any pattern is found in URL
     */
    function matchesPattern(matchPatterns) {
        if (!Array.isArray(matchPatterns)) matchPatterns = [matchPatterns];
        return matchPatterns.some(pattern => pattern === '*' || window.location.href.includes(pattern));
    }
    
    /**
     * Execute the dispatcher logic
     */
    function executeDispatcher() {
        // Processed manifest array with function names
        const processedManifest = ${JSON.stringify(processedManifest, null, 4)};
        
        
        // Iterate over manifest and execute matching scripts
        processedManifest.forEach((entry, index) => {
            try {
                const urlMatches = matchesPattern(entry.matches);
                
                if (urlMatches) {
                    console.log(\`"\${entry.name}" script loaded because it matches the URL pattern(s) [\${entry.matches.join(', ')}]\`);
                    
                    // Call the corresponding function
                    if (typeof window[entry.functionName] === 'function') {
                        window[entry.functionName]();
                    } else {
                        console.error(\`‚ùå Function \${entry.functionName} not found or not callable\`);
                    }
                }
            } catch (error) {
                console.error(\`‚ùå Error executing "\${entry.name}" (\${entry.functionName}):\`, error);
            }
        });
        
    }
    
    // Wait for DOM to be ready before executing dispatcher
    if (document.readyState === 'loading') {
        // DOM is still loading, wait for DOMContentLoaded
        document.addEventListener('DOMContentLoaded', executeDispatcher);
    } else {
        // DOM is already ready, execute immediately
        executeDispatcher();
    }
})();
} catch (e) {
    console.error("‚ùå [Bundler] Critical Error executing bundle:", e);
}
`

		bundleCode += dispatcherCode

		// Step 5: Write output file
		console.log(`üíæ Writing bundle to: ${OUTPUT_FILE}`)
		fs.writeFileSync(OUTPUT_FILE, bundleCode, "utf8")

		// Get file size for reporting
		const stats = fs.statSync(OUTPUT_FILE)
		const fileSizeKB = (stats.size / 1024).toFixed(2)

		console.log("üéâ Bundling completed successfully!")
		console.log(`üìä Bundle statistics:`)
		console.log(`   - Output file: ${OUTPUT_FILE}`)
		console.log(`   - File size: ${fileSizeKB} KB`)
		console.log(`   - Scripts processed: ${processedManifest.length}`)
		console.log(`   - Generated functions: ${processedManifest.map((e) => e.functionName).join(", ")}`)

		// Display usage instructions
		const absoluteBundlePath = path.resolve(OUTPUT_FILE)
		console.log("\nüìñ Usage Instructions:")
		console.log("1. Install the generated userscript_bundle.js in your userscript manager")
		console.log("2. Create a master userscript with the following content:")
		console.log("")
		console.log("// ==UserScript==")
		console.log("// @name         Local Userscript Dynamic Loader")
		console.log("// @match        *://*/*")
		console.log("// @grant        none")
		console.log("// @run-at       document-start")
		console.log(`// @require      file://${absoluteBundlePath}`)
		console.log("// ==/UserScript==")
		console.log("")
		console.log("3. The bundle will automatically detect the current page URL and execute the appropriate scripts")
	} catch (error) {
		console.error("‚ùå Bundling failed:", error.message)
		process.exit(1)
	}
}

// Execute the bundler if this script is run directly
if (require.main === module) {
	bundleUserscripts()
}

module.exports = { bundleUserscripts }
